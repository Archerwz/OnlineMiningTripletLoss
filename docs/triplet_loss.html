---

title: Title

keywords: fastai
sidebar: home_sidebar

summary: "summary"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: lib/triplet_loss.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
    
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Online-Mining-Triplet-Loss">Online Mining Triplet Loss<a class="anchor-link" href="#Online-Mining-Triplet-Loss">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Test-suite from https://github.com/omoindrot/tensorflow-triplet-loss/blob/master/model/tests/test_triplet_loss.py</span>
<span class="c1"># Skipped the `test_gradients_pairwise_distances()` test since it&#39;s trivial to see if your model loss turns NaN</span>
<span class="c1"># and porting it proved more difficult than expected.</span>

<span class="k">def</span> <span class="nf">pairwise_distance_np</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the pairwise distance matrix in numpy.</span>
<span class="sd">    Args:</span>
<span class="sd">        feature: 2-D numpy array of size [number of data, feature dimension]</span>
<span class="sd">        squared: Boolean. If true, output is the pairwise squared euclidean</span>
<span class="sd">                 distance matrix; else, output is the pairwise euclidean distance matrix.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pairwise_distances: 2-D numpy array of size</span>
<span class="sd">                            [number of data, number of data].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">upper_tri_pdists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="n">triu</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">feature</span><span class="p">[</span><span class="n">triu</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">squared</span><span class="p">:</span>
        <span class="n">upper_tri_pdists</span> <span class="o">**=</span> <span class="mf">2.</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pairwise_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_data</span><span class="p">,</span> <span class="n">num_data</span><span class="p">))</span>
    <span class="n">pairwise_distances</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">num_data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">upper_tri_pdists</span>
    <span class="c1"># Make symmetrical.</span>
    <span class="n">pairwise_distances</span> <span class="o">=</span> <span class="n">pairwise_distances</span> <span class="o">+</span> <span class="n">pairwise_distances</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
        <span class="n">pairwise_distances</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">pairwise_distances</span>

<span class="k">def</span> <span class="nf">test_pairwise_distances</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test the pairwise distances function.&quot;&quot;&quot;</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">feat_dim</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="n">embeddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_data</span><span class="p">,</span> <span class="n">feat_dim</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">embeddings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># to get distance 0</span>

    <span class="k">for</span> <span class="n">squared</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
        <span class="n">res_np</span> <span class="o">=</span> <span class="n">pairwise_distance_np</span><span class="p">(</span><span class="n">embeddings</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="n">squared</span><span class="p">)</span>
        <span class="n">res_pt</span> <span class="o">=</span> <span class="n">_pairwise_distances</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">embeddings</span><span class="p">),</span> <span class="n">squared</span><span class="o">=</span><span class="n">squared</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">res_np</span><span class="p">,</span> <span class="n">res_pt</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_pairwise_distances_are_positive</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test that the pairwise distances are always positive.</span>
<span class="sd">    Use a tricky case where numerical errors are common.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">feat_dim</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="c1"># Create embeddings very close to each other in [1.0 - 2e-7, 1.0 + 2e-7]</span>
    <span class="c1"># This will encourage errors in the computation</span>
    <span class="n">embeddings</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2e-7</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_data</span><span class="p">,</span> <span class="n">feat_dim</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">embeddings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># to get distance 0</span>

    <span class="k">for</span> <span class="n">squared</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
        <span class="n">res_tf</span> <span class="o">=</span> <span class="n">_pairwise_distances</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">embeddings</span><span class="p">),</span> <span class="n">squared</span><span class="o">=</span><span class="n">squared</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">res_tf</span><span class="p">[</span><span class="n">res_tf</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">test_triplet_mask</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test function _get_triplet_mask.&quot;&quot;&quot;</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">mask_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_data</span><span class="p">,</span> <span class="n">num_data</span><span class="p">,</span> <span class="n">num_data</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
                <span class="n">distinct</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">mask_np</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">distinct</span> <span class="ow">and</span> <span class="n">valid</span><span class="p">)</span>

    <span class="n">mask_tf_val</span> <span class="o">=</span> <span class="n">_get_triplet_mask</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">mask_np</span><span class="p">,</span> <span class="n">mask_tf_val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_anchor_positive_triplet_mask</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test function _get_anchor_positive_triplet_mask.&quot;&quot;&quot;</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">mask_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_data</span><span class="p">,</span> <span class="n">num_data</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
            <span class="n">distinct</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">mask_np</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">distinct</span> <span class="ow">and</span> <span class="n">valid</span><span class="p">)</span>

    <span class="n">mask_tf_val</span> <span class="o">=</span> <span class="n">_get_anchor_positive_triplet_mask</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">))</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">mask_np</span><span class="p">,</span> <span class="n">mask_tf_val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_anchor_negative_triplet_mask</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test function _get_anchor_negative_triplet_mask.&quot;&quot;&quot;</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">mask_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_data</span><span class="p">,</span> <span class="n">num_data</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
            <span class="n">distinct</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">mask_np</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">distinct</span> <span class="ow">and</span> <span class="n">valid</span><span class="p">)</span>

    <span class="n">mask_tf_val</span> <span class="o">=</span> <span class="n">_get_anchor_negative_triplet_mask</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">mask_np</span><span class="p">,</span> <span class="n">mask_tf_val</span><span class="p">)</span>

<span class="n">test_pairwise_distances</span><span class="p">()</span>
<span class="n">test_pairwise_distances_are_positive</span><span class="p">()</span>
<span class="n">test_triplet_mask</span><span class="p">()</span>
<span class="n">test_anchor_positive_triplet_mask</span><span class="p">()</span>
<span class="n">test_anchor_negative_triplet_mask</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="batch_hard_triplet_loss" class="doc_header"><code>batch_hard_triplet_loss</code><a href="online_triplet_loss/losses.py#L102" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>batch_hard_triplet_loss</code>(<strong><code>labels</code></strong>, <strong><code>embeddings</code></strong>, <strong><code>margin</code></strong>, <strong><code>squared</code></strong>=<em><code>False</code></em>, <strong><code>device</code></strong>=<em><code>'cpu'</code></em>)</p>
</blockquote>
<p>Build the triplet loss over a batch of embeddings.</p>
<p>For each anchor, we get the hardest positive and hardest negative to form a triplet.</p>
<p>Args:
    labels: labels of the batch, of size (batch_size,)
    embeddings: tensor of shape (batch_size, embed_dim)
    margin: margin for triplet loss
    squared: Boolean. If true, output is the pairwise squared euclidean distance matrix.
             If false, output is the pairwise euclidean distance matrix.</p>
<p>Returns:
    triplet_loss: scalar tensor containing the triplet loss</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="batch_all_triplet_loss" class="doc_header"><code>batch_all_triplet_loss</code><a href="online_triplet_loss/losses.py#L149" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>batch_all_triplet_loss</code>(<strong><code>labels</code></strong>, <strong><code>embeddings</code></strong>, <strong><code>margin</code></strong>, <strong><code>squared</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<p>Build the triplet loss over a batch of embeddings.</p>
<p>We generate all the valid triplets and average the loss over the positive ones.</p>
<p>Args:
    labels: labels of the batch, of size (batch_size,)
    embeddings: tensor of shape (batch_size, embed_dim)
    margin: margin for triplet loss
    squared: Boolean. If true, output is the pairwise squared euclidean distance matrix.
             If false, output is the pairwise euclidean distance matrix.</p>
<p>Returns:
    triplet_loss: scalar tensor containing the triplet loss</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">test_simple_batch_all_triplet_loss</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test the triplet loss with batch all triplet mining in a simple case.</span>
<span class="sd">    There is just one class in this super simple edge case, and we want to make sure that</span>
<span class="sd">    the loss is 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">feat_dim</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">embeddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_data</span><span class="p">,</span> <span class="n">feat_dim</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">labels</span><span class="p">,</span> <span class="n">embeddings</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">squared</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
        <span class="n">loss_np</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Compute the loss in TF.</span>
        <span class="n">loss_tf_val</span><span class="p">,</span> <span class="n">fraction_val</span> <span class="o">=</span> <span class="n">batch_all_triplet_loss</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="n">squared</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">loss_np</span><span class="p">,</span> <span class="n">loss_tf_val</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">fraction_val</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_batch_all_triplet_loss</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test the triplet loss with batch all triplet mining&quot;&quot;&quot;</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">feat_dim</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">embeddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_data</span><span class="p">,</span> <span class="n">feat_dim</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">squared</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
        <span class="n">pdist_matrix</span> <span class="o">=</span> <span class="n">pairwise_distance_np</span><span class="p">(</span><span class="n">embeddings</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="n">squared</span><span class="p">)</span>

        <span class="n">loss_np</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">num_positives</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">num_valid</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
                    <span class="n">distinct</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">k</span><span class="p">)</span>
                    <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">distinct</span> <span class="ow">and</span> <span class="n">valid</span><span class="p">:</span>
                        <span class="n">num_valid</span> <span class="o">+=</span> <span class="mf">1.0</span>

                        <span class="n">pos_distance</span> <span class="o">=</span> <span class="n">pdist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">neg_distance</span> <span class="o">=</span> <span class="n">pdist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>

                        <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">pos_distance</span> <span class="o">-</span> <span class="n">neg_distance</span> <span class="o">+</span> <span class="n">margin</span><span class="p">)</span>
                        <span class="n">loss_np</span> <span class="o">+=</span> <span class="n">loss</span>

                        <span class="n">num_positives</span> <span class="o">+=</span> <span class="p">(</span><span class="n">loss</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">loss_np</span> <span class="o">/=</span> <span class="n">num_positives</span>

        <span class="c1"># Compute the loss in TF.</span>
        <span class="n">loss_tf_val</span><span class="p">,</span> <span class="n">fraction_val</span> <span class="o">=</span> <span class="n">batch_all_triplet_loss</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">embeddings</span><span class="p">),</span> <span class="n">margin</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="n">squared</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">loss_np</span><span class="p">,</span> <span class="n">loss_tf_val</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">num_positives</span> <span class="o">/</span> <span class="n">num_valid</span><span class="p">,</span> <span class="n">fraction_val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_batch_hard_triplet_loss</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test the triplet loss with batch hard triplet mining&quot;&quot;&quot;</span>
    <span class="n">num_data</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">feat_dim</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">embeddings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_data</span><span class="p">,</span> <span class="n">feat_dim</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">squared</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
        <span class="n">pdist_matrix</span> <span class="o">=</span> <span class="n">pairwise_distance_np</span><span class="p">(</span><span class="n">embeddings</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="n">squared</span><span class="p">)</span>

        <span class="n">loss_np</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_data</span><span class="p">):</span>
            <span class="c1"># Select the hardest positive</span>
            <span class="n">max_pos_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pdist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">labels</span> <span class="o">==</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="c1"># Select the hardest negative</span>
            <span class="n">min_neg_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pdist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">labels</span> <span class="o">!=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">max_pos_dist</span> <span class="o">-</span> <span class="n">min_neg_dist</span> <span class="o">+</span> <span class="n">margin</span><span class="p">)</span>
            <span class="n">loss_np</span> <span class="o">+=</span> <span class="n">loss</span>

        <span class="n">loss_np</span> <span class="o">/=</span> <span class="n">num_data</span>

        <span class="c1"># Compute the loss in TF.</span>
        <span class="n">loss_tf_val</span> <span class="o">=</span> <span class="n">batch_hard_triplet_loss</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">embeddings</span><span class="p">),</span> <span class="n">margin</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="n">squared</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">loss_np</span><span class="p">,</span> <span class="n">loss_tf_val</span><span class="p">)</span>

<span class="n">test_simple_batch_all_triplet_loss</span><span class="p">()</span>
<span class="n">test_batch_all_triplet_loss</span><span class="p">()</span>
<span class="n">test_batch_hard_triplet_loss</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tensor(0.) tensor(0.)
tensor(0.) tensor(0.)
tensor(0.6439) tensor(0.6181)
tensor(0.3970) tensor(0.7083)
</pre>
</div>
</div>

</div>
</div>

</div>
</div>
 

